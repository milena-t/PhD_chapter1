# plot the results from compare_gene_positions.sh

from dataclasses import dataclass


# import src.parse_gff as gff
import parse_gff as gff

import matplotlib.pyplot as plt
from plot_basics import plot_tree_manually

# to correctly compute the overlap, first correct the contig names of the orthoDB annotation to match the native annotations with correct_native_contig_names_for_bedtools_intersect.py
# files generated on uppmax are here: /proj/naiss2023-6-65/Milena/annotation_pipeline/annotation_evaluation/gene_position_comparison_native_vs_orhtoDB
# use the "complete.txt" files generated by bedtools intersect with -wa and -wb that look like this:
#       native_feature 0 10 orthodb_feature_a 0 3 
#       native_feature 0 10 orthodb_feature_b 6 9
# they include coordinates for the overlap behind the id


@dataclass
class SingleOverlap:
    native_id:str
    native_overlap_start:int
    native_overlap_stop:int
    orthoDB_id:str
    orthoDB_overlap_start:int
    orthoDB_overlap_stop:int

@dataclass
class OverlapsDict:
    feature_id:str 
    annot_source:str # is the feature from the native or orthoDB annotation
    contig:str
    # overlaps:dict[str,SingleOverlap] # { feature_id : SingleOverlap }
    
    # def add_overlap(self, new_overlap:SingleOverlap):
    #     if self.annot_source == "native":
    #         self.overlaps[new_overlap.orthoDB_id] = new_overlap
    #     if self.annot_source == "orthoDB":
    #         self.overlaps[new_overlap.native_id] = new_overlap

    overlaps:list[SingleOverlap]

    def add_overlap(self, new_overlap:SingleOverlap):
        self.overlaps.append(new_overlap)

    @property
    def overlap_length(self):
        length = 0
        # no need to test for native or orthoDB since the results should be the same
        for overlap in self.overlaps.values():
            length += abs(overlap.orthoDB_overlap_start-overlap.orthoDB_overlap_stop)
        return(length)
    
    @property
    def count_overlap_features(self):
        return(len(self.overlaps))

    @property
    def show(self):
        print(f"overlaps of {self.feature_id} from {self.annot_source} annotation:")
        print(f"there are {self.count_overlap_features} matches:")
        if self.annot_source == "native":
            for overlap in self.overlaps:
                print(f"\t* ID: {overlap.orthoDB_id} ,  on {self.contig} from {overlap.orthoDB_overlap_start} to {overlap.orthoDB_overlap_stop}")
        if self.annot_source == "orthoDB":
            for overlap in self.overlaps:
                print(f"\t* ID: {overlap.native_id} ,  on {self.contig} from {overlap.native_overlap_start} to {overlap.native_overlap_stop}")




def read_overlaps(overlaps_filepath:str, verbose = False) -> dict[str:OverlapsDict]:
    """
    read the output file from bedtools intersect into the above defined datastructures
    the keys are all native and orthoDB gene ids that occur in the files, and the values are instances of OverlapsDict
    """
    
    overlaps_dict = {}

    with open(overlaps_filepath, "r") as overlaps_file:
        if verbose:
            print(f" --> reading overlaps file: {overlaps_filepath}")
        for overlap_str in overlaps_file:
            orthodb_annotation = {}
            native_annotation = {}
            column_names = [
                "contig",
                "prediction_method", #this is the source of the gene prediction, the second column in a gff file. but calling it source here would be misleading so i don't
                "category",
                "start",
                "stop",
                "score",
                "strandedness",
                "frame",
                "attributes"
            ]

            overlap_list = overlap_str.strip().split("\t")
            for i, element in enumerate(overlap_list[:9]):
                native_annotation[column_names[i]] = element
                
            for i, element in enumerate(overlap_list[9:]):
                orthodb_annotation[column_names[i]] = element

            # native attributes can be in some different formats with either "ID=id_string;..." or "ID id_string;..."
            native_id = native_annotation["attributes"].split(";")[0]
            if "ID=" in native_id:
                native_id = native_id.split("ID=")[-1]
            else:
                native_id = native_id.split(" ")[-1]

            orthodb_id = orthodb_annotation["attributes"].split(";")[0]# .split["ID="][-1]
            orthodb_id = orthodb_id.split("=")[-1]
            
            overlap = SingleOverlap(native_id=native_id, native_overlap_start=native_annotation["start"], native_overlap_stop=native_annotation["stop"], orthoDB_id=orthodb_id, orthoDB_overlap_start=orthodb_annotation["start"], orthoDB_overlap_stop=orthodb_annotation["stop"])

            if overlap.native_id not in overlaps_dict:
                overlaps_dict[overlap.native_id] = OverlapsDict(feature_id=overlap.native_id, annot_source="native", contig = native_annotation["contig"], overlaps=[overlap])
            elif overlap.native_id in overlaps_dict:
                overlaps_dict[overlap.native_id].add_overlap(overlap)
                # print(overlaps_dict)
                # break

            if overlap.orthoDB_id not in overlaps_dict:
                overlaps_dict[overlap.orthoDB_id] = OverlapsDict(feature_id=overlap.orthoDB_id, annot_source="orthoDB", contig = orthodb_annotation["contig"],overlaps=[overlap])
            elif overlap.orthoDB_id in overlaps_dict:
                overlaps_dict[overlap.orthoDB_id].add_overlap(overlap)
        if verbose:
            print(f"\t {len(overlaps_dict)} features read in overlaps list")
        return(overlaps_dict)


def process_overlap_dict(overlaps_dict, min_overlap_len=10, read_orthoDB = True):
    """
    Processes the dictionary returned from read_overlaps() 
    and returns the numbers necessary for plotting:
    * number of features that have one overlap (reciprocal, are 1:1 shared)
        -> require minimum overlap length
    * number of features that have 1:n overlap (native_1:orthoDB_n)
    * number of features that have n:1 overlap (native_n:orthoDB_1)
    * number of native features that have no overlap
    * number of orthoDB features that have no overlap
    """
    
    out_dict = {
        "1-to-1_overlaps_from_nat" : 0,
        "1-to-1_overlaps_from_oDB" : 0,
        "1-to-n_native" : 0, # 1 native feature overlaps with multiple orthoDB features
        "n-to-1_orthoDB" : 0, # 1 orthoDB feature overlaps with multiple native features
        "n-to-n_overlaps" : 0
    }

    single_match = {}
    native_multi_match = {}
    orthoDB_multi_match = {}
    multi_match = {}
    
    # TODO something is still weird about counting this

    for overlap_feature in overlaps_dict.values():
        if overlap_feature.annot_source == "native":
            orthoDB_match = overlap_feature.overlaps[0].orthoDB_id
            # 1-to-1 and n-to-n only counted from native perspective since otherwise these two would be counted double
            if overlap_feature.count_overlap_features == 1:
                if overlaps_dict[orthoDB_match].count_overlap_features == 1:
                    out_dict["1-to-1_overlaps_from_nat"] +=1

                    # single_match[overlap_feature.feature_id] = overlap_feature # only from native perspective
                else:
                    out_dict["n-to-1_orthoDB"] +=1 # if that orthoDB feature that's alone in it's native list also matches other native features
                    # native_multi_match[overlap_feature.feature_id] = overlap_feature
                    # overlap_feature.show
            else:
                if overlaps_dict[orthoDB_match].count_overlap_features >1:
                    out_dict["n-to-n_overlaps"] +=1
                    # multi_match[overlap_feature.feature_id] = overlap_feature

        elif overlap_feature.annot_source == "orthoDB" and read_orthoDB:
            native_match = overlap_feature.overlaps[0].native_id
            if overlap_feature.count_overlap_features == 1:
                if overlaps_dict[orthoDB_match].count_overlap_features == 1:
                    out_dict["1-to-1_overlaps_from_oDB"] +=1
                if overlaps_dict[native_match].count_overlap_features > 0:
                    out_dict["1-to-n_native"] += 1
                    # orthoDB_multi_match[overlap_feature.feature_id] = overlap_feature
        
    return(out_dict)


def get_unmatched_number(filepath):
    """
    get number of unmatched features and all features from output files
    """

    with open(filepath, "r") as file:
        unmatched = 0
        all_features = 0
        for line in file:
            line = line.strip()
            all_features+=1
            if line[-1] == "0":
                unmatched += 1
    return(unmatched, all_features)




def read_overlap_num_file(filepath, verbose = False):
    """
    get number of all kinds of feature matches in dictionary like this:
    out_dict = {
        "no_overlap" : [list, of, feature, IDs],
        "one_overlap" : [list, of, feature, IDs],
        "multi_overlaps" : [list, of, feature, IDs]
    }
    """
    out_dict = {
        "no_overlap" : [],
        "one_overlap" : [],
        "multi_overlaps" : []
    }
    all_features = 0
    with open(filepath, "r") as file:
        for line in file:
            try:
                feature,attributes,no_matches = line.strip().split("\t")
            except:
                line = line.strip().split("\t")
                print(line)
                raise RuntimeError("Wrong number of columns")
            all_features+=1
            feature_id = attributes.split(";")[0]
            if "ID=" in feature_id:
                feature_id = feature_id.split("ID=")[-1]
            else:
                feature_id = feature_id.split(" ")[-1]
            
            if no_matches == "0":
                out_dict["no_overlap"].append(feature_id)
            elif no_matches == "1":
                out_dict["one_overlap"].append(feature_id)
            else:
                out_dict["multi_overlaps"].append(feature_id)
    if verbose:
        for key,value in out_dict.items():
            print(f" * {key} : {len(value)}")
    return(out_dict)



def get_species_values(species_name:str, overlap_files:dict, native_query:dict, orthodb_query:dict, proportions = True):
    """
    Get the values required for plotting. The "species_name" should be a key in the
    dictionaries that contain the filepaths for all the bedtools intersect output
    If you don't want all the absolute numbers, you can use the "proportions" option 
    to get it all divided by the complete number of orthoDB or native features respectively.
    """
    
    all_overlaps_dict = read_overlaps(overlap_files[species_name])
    processed_dict = process_overlap_dict(all_overlaps_dict, read_orthoDB=True)
    processed_dict["unmatched_native"], processed_dict["all_native"] = get_unmatched_number(native_query[species_name])
    processed_dict["unmatched_orthoDB"], processed_dict["all_orthoDB"]  = get_unmatched_number(orthodb_query[species_name])

    all_nat = processed_dict["all_native"]
    unm_nat = processed_dict["unmatched_native"]
    all_odb = processed_dict["all_orthoDB"]
    unm_odb = processed_dict["unmatched_orthoDB"]
    print(f"\t {all_nat+all_odb-unm_nat-unm_odb} features should have one or more overlaps from both annotations = {all_nat} + {all_odb} - {unm_nat} - {unm_odb}")

    out_dict = {}
    native_vals = {}
    odb_vals = {}
    if proportions:
        for key in processed_dict.keys():
            curr_num_features = processed_dict[key]
            if "native" in key:
                out_dict[f"{key}_proportion"] = curr_num_features/processed_dict["all_native"]
                native_vals[f"{key}_proportion"] = curr_num_features/processed_dict["all_native"]
            elif "orthoDB" in key:
                out_dict[f"{key}_proportion"] = curr_num_features/processed_dict["all_orthoDB"]
                odb_vals[f"{key}_proportion"] = curr_num_features/processed_dict["all_orthoDB"]
            else:
                out_dict[f"{key}_proportion_native"] = curr_num_features/processed_dict["all_native"]
                native_vals[f"{key}_proportion_native"] = curr_num_features/processed_dict["all_native"]
                out_dict[f"{key}_proportion_orthoDB"] = curr_num_features/processed_dict["all_orthoDB"]
                odb_vals[f"{key}_proportion_orthoDB"] = curr_num_features/processed_dict["all_orthoDB"]
        # print(native_vals)
        sum_nat = sum(list(native_vals.values()))
        print(f"\t sum all native proportions: {sum_nat-1:.2f} (should be 1.0)")
        # print(odb_vals)
        sum_odb = sum(list(odb_vals.values()))
        print(f"\t sum all orthoDB proportions: {sum_odb-1:.2f} (should be 1.0)")

        return(out_dict)

    else:
        return(processed_dict)


def get_reciprocal_1to1(all_overlaps_dict, feature_ids_one_overlap, verbose = False):
    """
    Take the all_overlaps_dict that is the output of read_overlaps
    and the ["one_overlap"] output of read_overlap_num_file (features that have unidirectional only one overlap)
    and get the sub-list of features that have only one overlap in both directions 
    """
    # get the ids of the overlap hits in the other annotation (double check if they truly have only one feature match)
    # print(all_overlaps_dict[feature_ids_one_overlap[0]].annot_source)
    if all_overlaps_dict[feature_ids_one_overlap[0]].annot_source == "native":
        annot_source = "native"
        other_annot = "orthoDB"
        feature_ids_one_overlap_other_annotation = [all_overlaps_dict[feature_id].overlaps[0].orthoDB_id for feature_id in feature_ids_one_overlap if all_overlaps_dict[feature_id].count_overlap_features == 1]
    if all_overlaps_dict[feature_ids_one_overlap[0]].annot_source == "orthoDB":
        other_annot = "native"
        annot_source = "orthoDB"
        feature_ids_one_overlap_other_annotation = [all_overlaps_dict[feature_id].overlaps[0].native_id for feature_id in feature_ids_one_overlap if all_overlaps_dict[feature_id].count_overlap_features == 1]

    count_non_reciprocal_1to1 = 0
    input_annot_ids = []
    other_annot_ids = []
    for other_annot_id in feature_ids_one_overlap_other_annotation:
        if all_overlaps_dict[other_annot_id].count_overlap_features !=1:
            # all_overlaps_dict[other_annot_id].show
            count_non_reciprocal_1to1+=1
        else:
            other_annot_ids.append(other_annot_id)

    if verbose:
        print(f"{len(feature_ids_one_overlap)} input IDs from {annot_source} with one overlap, {len(feature_ids_one_overlap_other_annotation)} {other_annot} IDs they overlap with, ")
        print(f"{count_non_reciprocal_1to1} of those {other_annot} IDs overlap with multiple {annot_source} IDs, leaving --> {len(feature_ids_one_overlap_other_annotation) - count_non_reciprocal_1to1} <-- reciprocal 1-to-1 matches")
        print(f"{len(other_annot_ids)} IDs from {other_annot} in the output list")
    
    return(other_annot_ids)

def get_plot_numbers(overlap_lists, onetoone_list, ratio = True, verbose = False):

    required_overlap_numbers = {
        "no_overlap" : len(overlap_lists["no_overlap"]),
        "1to1_overlap" : len(onetoone_list),
        "all_features" : sum([len(list(value)) for key, value in overlap_lists.items()] ),
        "multi_overlap" : sum([len(list(value)) for key, value in overlap_lists.items()]) - len(native_1to1) - len(overlap_lists["no_overlap"])
    }

    if ratio:
        all_features = required_overlap_numbers["all_features"]
        for key in required_overlap_numbers.keys():
            required_overlap_numbers[key] = required_overlap_numbers[key]/all_features

    if verbose:
        print()
        for key, value in required_overlap_numbers.items():
            print(f"\t{key} :  {value:.2f}")
        if (ratio):
            print(f"\t --> sum of all subsets: {required_overlap_numbers['1to1_overlap'] + required_overlap_numbers['multi_overlap'] + required_overlap_numbers['no_overlap']} ")

    return(required_overlap_numbers)



def plot_all_species_values(all_values_native_dict, all_values_orthoDB_dict, species_names_list = [], filename = ""):
    """
    Plot all of the values, species names specify the order in the x axis.
    species_names_list can be a list of species names that determines the order, 
    or it can be 
    """

    if len(species_names_list) == 0:
        species_names_list = list(all_values_orthoDB_dict.keys())
    elif len(species_names_list) > 0 and type(species_names_list) == str:
        # if the species name is actually a string then assume it's a filepath to a newick tree
        # don't give an axis to plot and it will just return a species tree order
        species_names_list = plot_tree_manually(species_names_list)
    

    fs = 13 # set font size
    # plot each column in the dataframe as a line in the same plot thorugh a for-loop
    fig = plt.figure(figsize=(10,9))
    
    ax = fig.add_subplot(1, 1, 1)
    
    ylab="proportion of total number of annotated features"
    # get a list of lists with [native, orthoDB] number of gene families per species

    categories = [
        "no_overlap",
        "1to1_overlap",
        "multi_overlap"
    ]

    point_markers = {
        "no_overlap" : "x",
        "1to1_overlap" : ".",
        "multi_overlap" : "v"
    }

    line_style = {
        "no_overlap" : ":",
        "1to1_overlap" : "-",
        "multi_overlap" : "-."
    }

    native_annot_red = "#b82946"
    orthoDB_annot_yellow = "#F2933A"

    values_native = {}
    values_orthoDB = {}
    for category in categories:
        values_native[category] = [all_values_native_dict[species][category] for species in species_names_list]        
        values_orthoDB[category] = [all_values_orthoDB_dict[species][category] for species in species_names_list]  

    for category in ["no_overlap","multi_overlap"]:
        ax.scatter(species_names_list, values_native[category], color = native_annot_red, marker = point_markers[category], label = category+"_native")
        ax.scatter(species_names_list, values_orthoDB[category], color = orthoDB_annot_yellow, marker = point_markers[category], label = category+"_orthoDB")

    ax.plot(species_names_list, values_native["1to1_overlap"], color = native_annot_red, linestyle = line_style["1to1_overlap"], label = "1to1_overlap_native")
    ax.plot(species_names_list, values_orthoDB["1to1_overlap"], color = orthoDB_annot_yellow, linestyle = line_style["1to1_overlap"], label = "1to1_overlap_orthoDB")
    
    ax.set_ylim(0, 1.05)
    plt.xticks(labels=[species.replace("_", ". ") for species in species_names_list], ticks=species_names_list, rotation = 90, fontsize = fs)
    plt.tight_layout()
    ax.set_ylabel(ylab, fontsize = fs)

    handles, labels = ax.get_legend_handles_labels()
    labels = [label.replace("_", " ").replace("orthoDB", "uniform") for label in labels]
    ax.legend(handles, labels)

    # set x-axis grid
    ax.grid(True)
    ax.yaxis.grid(False)

    if len(filename) == 0:
        filename = "annotaion_overlaps.png"
    plt.savefig(filename, dpi = 300, transparent = True, bbox_inches='tight')
    print(f"plot saved in current working directory as: {filename}")
    # plt.show()

    # native
    #



if __name__ == "__main__":

    # rsync -azP "milenatr@rackham.uppmax.uu.se:/proj/naiss2023-6-65/Milena/annotation_pipeline/annotation_evaluation/gene_position_comparison_native_vs_orhtoDB/*txt" .
    # rsync -azP "milenatr@rackham.uppmax.uu.se:/proj/naiss2023-6-65/Milena/annotation_pipeline/annotation_evaluation/gene_position_comparison_native_vs_orhtoDB/exon_overlaps/*txt" .

    overlap_transcript_path = "/Users/miltr339/work/gene_position_comparison_native_vs_orhtoDB/"
    if True:
        overlap_files_transcript = {
            "A_obtectus" : f"{overlap_transcript_path}A_obtectus_transcript_overlap_stats_complete.txt",
            "A_verrucosus" : f"{overlap_transcript_path}A_verrucosus_transcript_overlap_stats_complete.txt",
            "B_siliquastri" : f"{overlap_transcript_path}B_siliquastri_transcript_overlap_stats_complete.txt",
            "C_analis" : f"{overlap_transcript_path}C_analis_transcript_overlap_stats_complete.txt",
            "C_chinensis" : f"{overlap_transcript_path}C_chinensis_transcript_overlap_stats_complete.txt",
            "C_maculatus" : f"{overlap_transcript_path}C_maculatus_superscaffolded_transcript_overlap_stats_complete.txt",
            "C_septempunctata" : f"{overlap_transcript_path}C_septempunctata_transcript_overlap_stats_complete.txt",
            "D_melanogaster" : f"{overlap_transcript_path}D_melanogaster_transcript_overlap_stats_complete.txt",
            "D_ponderosae" : f"{overlap_transcript_path}D_ponderosae_transcript_overlap_stats_complete.txt",
            "I_luminosus" : f"{overlap_transcript_path}I_luminosus_transcript_overlap_stats_complete.txt",
            "P_pyralis" : f"{overlap_transcript_path}P_pyralis_transcript_overlap_stats_complete.txt",
            "R_ferrugineus" : f"{overlap_transcript_path}R_ferrugineus_transcript_overlap_stats_complete.txt",
            "T_castaneum" : f"{overlap_transcript_path}T_castaneum_transcript_overlap_stats_complete.txt",
            "T_molitor" : f"{overlap_transcript_path}T_molitor_transcript_overlap_stats_complete.txt",
            "Z_morio" : f"{overlap_transcript_path}Z_morio_transcript_overlap_stats_complete.txt",
        }

        native_query_transcript = {
            "A_obtectus": f"{overlap_transcript_path}A_obtectus_transcript_overlap_stats_numbers_only_native_query.txt",
            "A_verrucosus": f"{overlap_transcript_path}A_verrucosus_transcript_overlap_stats_numbers_only_native_query.txt",
            "B_siliquastri": f"{overlap_transcript_path}B_siliquastri_transcript_overlap_stats_numbers_only_native_query.txt",
            "C_analis": f"{overlap_transcript_path}C_analis_transcript_overlap_stats_numbers_only_native_query.txt",
            "C_chinensis": f"{overlap_transcript_path}C_chinensis_transcript_overlap_stats_numbers_only_native_query.txt",
            "C_maculatus": f"{overlap_transcript_path}C_maculatus_superscaffolded_transcript_overlap_stats_numbers_only_native_query.txt",
            "C_septempunctata": f"{overlap_transcript_path}C_septempunctata_transcript_overlap_stats_numbers_only_native_query.txt",
            "D_melanogaster": f"{overlap_transcript_path}D_melanogaster_transcript_overlap_stats_numbers_only_native_query.txt",
            "D_ponderosae": f"{overlap_transcript_path}D_ponderosae_transcript_overlap_stats_numbers_only_native_query.txt",
            "I_luminosus": f"{overlap_transcript_path}I_luminosus_transcript_overlap_stats_numbers_only_native_query.txt",
            "P_pyralis": f"{overlap_transcript_path}P_pyralis_transcript_overlap_stats_numbers_only_native_query.txt",
            "R_ferrugineus": f"{overlap_transcript_path}R_ferrugineus_transcript_overlap_stats_numbers_only_native_query.txt",
            "T_castaneum": f"{overlap_transcript_path}T_castaneum_transcript_overlap_stats_numbers_only_native_query.txt",
            "T_molitor": f"{overlap_transcript_path}T_molitor_transcript_overlap_stats_numbers_only_native_query.txt",
            "Z_morio": f"{overlap_transcript_path}Z_morio_transcript_overlap_stats_numbers_only_native_query.txt",
        }

        orthodb_query_transcript = {
            "A_obtectus" : f"{overlap_transcript_path}A_obtectus_transcript_overlap_stats_numbers_only_orthodb_query.txt",
            "A_verrucosus" : f"{overlap_transcript_path}A_verrucosus_transcript_overlap_stats_numbers_only_orthodb_query.txt",
            "B_siliquastri" : f"{overlap_transcript_path}B_siliquastri_transcript_overlap_stats_numbers_only_orthodb_query.txt",
            "C_analis" : f"{overlap_transcript_path}C_analis_transcript_overlap_stats_numbers_only_orthodb_query.txt",
            "C_chinensis" : f"{overlap_transcript_path}C_chinensis_transcript_overlap_stats_numbers_only_orthodb_query.txt",
            "C_maculatus" : f"{overlap_transcript_path}C_maculatus_superscaffolded_transcript_overlap_stats_numbers_only_orthodb_query.txt",
            "C_septempunctata" : f"{overlap_transcript_path}C_septempunctata_transcript_overlap_stats_numbers_only_orthodb_query.txt",
            "D_melanogaster" : f"{overlap_transcript_path}D_melanogaster_transcript_overlap_stats_numbers_only_orthodb_query.txt",
            "D_ponderosae" : f"{overlap_transcript_path}D_ponderosae_transcript_overlap_stats_numbers_only_orthodb_query.txt",
            "I_luminosus" : f"{overlap_transcript_path}I_luminosus_transcript_overlap_stats_numbers_only_orthodb_query.txt",
            "P_pyralis" : f"{overlap_transcript_path}P_pyralis_transcript_overlap_stats_numbers_only_orthodb_query.txt",
            "R_ferrugineus" : f"{overlap_transcript_path}R_ferrugineus_transcript_overlap_stats_numbers_only_orthodb_query.txt",
            "T_castaneum" : f"{overlap_transcript_path}T_castaneum_transcript_overlap_stats_numbers_only_orthodb_query.txt",
            "T_molitor" : f"{overlap_transcript_path}T_molitor_transcript_overlap_stats_numbers_only_orthodb_query.txt",
            "Z_morio" : f"{overlap_transcript_path}Z_morio_transcript_overlap_stats_numbers_only_orthodb_query.txt",
        }

    overlap_exon_path = "/Users/miltr339/work/gene_position_comparison_native_vs_orhtoDB/exon_overlaps/"
    if True:
        overlap_files_exon = {
            "A_obtectus" : f"{overlap_exon_path}A_obtectus_transcript_overlap_stats_complete.txt",
            "A_verrucosus" : f"{overlap_exon_path}A_verrucosus_transcript_overlap_stats_complete.txt",
            "B_siliquastri" : f"{overlap_exon_path}B_siliquastri_transcript_overlap_stats_complete.txt",
            "C_analis" : f"{overlap_exon_path}C_analis_transcript_overlap_stats_complete.txt",
            "C_chinensis" : f"{overlap_exon_path}C_chinensis_transcript_overlap_stats_complete.txt",
            "C_maculatus" : f"{overlap_exon_path}C_maculatus_superscaffolded_transcript_overlap_stats_complete.txt",
            "C_septempunctata" : f"{overlap_exon_path}C_septempunctata_transcript_overlap_stats_complete.txt",
            "D_melanogaster" : f"{overlap_exon_path}D_melanogaster_transcript_overlap_stats_complete.txt",
            "D_ponderosae" : f"{overlap_exon_path}D_ponderosae_transcript_overlap_stats_complete.txt",
            "I_luminosus" : f"{overlap_exon_path}I_luminosus_transcript_overlap_stats_complete.txt",
            "P_pyralis" : f"{overlap_exon_path}P_pyralis_transcript_overlap_stats_complete.txt",
            "R_ferrugineus" : f"{overlap_exon_path}R_ferrugineus_transcript_overlap_stats_complete.txt",
            "T_castaneum" : f"{overlap_exon_path}T_castaneum_transcript_overlap_stats_complete.txt",
            "T_molitor" : f"{overlap_exon_path}T_molitor_transcript_overlap_stats_complete.txt",
            "Z_morio" : f"{overlap_exon_path}Z_morio_transcript_overlap_stats_complete.txt",
        }

        native_query_exon = {
            "A_obtectus": f"{overlap_exon_path}A_obtectus_transcript_overlap_stats_numbers_only_native_query.txt",
            "A_verrucosus": f"{overlap_exon_path}A_verrucosus_transcript_overlap_stats_numbers_only_native_query.txt",
            "B_siliquastri": f"{overlap_exon_path}B_siliquastri_transcript_overlap_stats_numbers_only_native_query.txt",
            "C_analis": f"{overlap_exon_path}C_analis_transcript_overlap_stats_numbers_only_native_query.txt",
            "C_chinensis": f"{overlap_exon_path}C_chinensis_transcript_overlap_stats_numbers_only_native_query.txt",
            "C_maculatus": f"{overlap_exon_path}C_maculatus_superscaffolded_transcript_overlap_stats_numbers_only_native_query.txt",
            "C_septempunctata": f"{overlap_exon_path}C_septempunctata_transcript_overlap_stats_numbers_only_native_query.txt",
            "D_melanogaster": f"{overlap_exon_path}D_melanogaster_transcript_overlap_stats_numbers_only_native_query.txt",
            "D_ponderosae": f"{overlap_exon_path}D_ponderosae_transcript_overlap_stats_numbers_only_native_query.txt",
            "I_luminosus": f"{overlap_exon_path}I_luminosus_transcript_overlap_stats_numbers_only_native_query.txt",
            "P_pyralis": f"{overlap_exon_path}P_pyralis_transcript_overlap_stats_numbers_only_native_query.txt",
            "R_ferrugineus": f"{overlap_exon_path}R_ferrugineus_transcript_overlap_stats_numbers_only_native_query.txt",
            "T_castaneum": f"{overlap_exon_path}T_castaneum_transcript_overlap_stats_numbers_only_native_query.txt",
            "T_molitor": f"{overlap_exon_path}T_molitor_transcript_overlap_stats_numbers_only_native_query.txt",
            "Z_morio": f"{overlap_exon_path}Z_morio_transcript_overlap_stats_numbers_only_native_query.txt",
        }

        orthodb_query_exon = {
            "A_obtectus" : f"{overlap_exon_path}A_obtectus_transcript_overlap_stats_numbers_only_orthodb_query.txt",
            "A_verrucosus" : f"{overlap_exon_path}A_verrucosus_transcript_overlap_stats_numbers_only_orthodb_query.txt",
            "B_siliquastri" : f"{overlap_exon_path}B_siliquastri_transcript_overlap_stats_numbers_only_orthodb_query.txt",
            "C_analis" : f"{overlap_exon_path}C_analis_transcript_overlap_stats_numbers_only_orthodb_query.txt",
            "C_chinensis" : f"{overlap_exon_path}C_chinensis_transcript_overlap_stats_numbers_only_orthodb_query.txt",
            "C_maculatus" : f"{overlap_exon_path}C_maculatus_superscaffolded_transcript_overlap_stats_numbers_only_orthodb_query.txt",
            "C_septempunctata" : f"{overlap_exon_path}C_septempunctata_transcript_overlap_stats_numbers_only_orthodb_query.txt",
            "D_melanogaster" : f"{overlap_exon_path}D_melanogaster_transcript_overlap_stats_numbers_only_orthodb_query.txt",
            "D_ponderosae" : f"{overlap_exon_path}D_ponderosae_transcript_overlap_stats_numbers_only_orthodb_query.txt",
            "I_luminosus" : f"{overlap_exon_path}I_luminosus_transcript_overlap_stats_numbers_only_orthodb_query.txt",
            "P_pyralis" : f"{overlap_exon_path}P_pyralis_transcript_overlap_stats_numbers_only_orthodb_query.txt",
            "R_ferrugineus" : f"{overlap_exon_path}R_ferrugineus_transcript_overlap_stats_numbers_only_orthodb_query.txt",
            "T_castaneum" : f"{overlap_exon_path}T_castaneum_transcript_overlap_stats_numbers_only_orthodb_query.txt",
            "T_molitor" : f"{overlap_exon_path}T_molitor_transcript_overlap_stats_numbers_only_orthodb_query.txt",
            "Z_morio" : f"{overlap_exon_path}Z_morio_transcript_overlap_stats_numbers_only_orthodb_query.txt",
        }

    species_name = "B_siliquastri"
    if False:
        ### no clue why this is wrong but the numbers don't add up at all


        # get all the values for all species
        print("\n\t --> transcripts")
        processed_dict_transcripts_nums = get_species_values(species_name, overlap_files_transcript, native_query_transcript, orthodb_query_transcript, proportions = False)
        # print(processed_dict_transcripts_nums)
        processed_dict_transcripts = get_species_values(species_name, overlap_files_transcript, native_query_transcript, orthodb_query_transcript, proportions = True)
        for key, value in processed_dict_transcripts_nums.items():
            print(f"\t\t * {key} :  {value:.1f} ")
        # print(processed_dict_transcripts)

        print("\n\t --> exons")
        processed_dict_exon_nums = get_species_values(species_name, overlap_files_exon, native_query_exon, orthodb_query_exon, proportions = False)
        # print(processed_dict_exon_nums)
        processed_dict_exon = get_species_values(species_name, overlap_files_exon, native_query_exon, orthodb_query_exon, proportions = True)
        for key, value in processed_dict_exon_nums.items():
            print(f"\t\t * {key} :  {value:.1f}")
        # print(processed_dict_exon)
    
    ## --> transcript features
    if True:
        all_species_values_native = {}
        all_species_values_orthoDB = {}
        
        verbose = False
        
        if verbose:
            print(f"get all values for all species:")
        for species_name in overlap_files_transcript.keys():
        #for species_name in tqdm(overlap_files_transcript.keys()): 
            if verbose:
                print(f"\n\n================> {species_name} <================")
            
            all_overlaps_dict = read_overlaps(overlap_files_transcript[species_name], verbose=verbose)
            if verbose:
                print("\n\t --> transcripts (native)")

            overlap_lists_native = read_overlap_num_file(native_query_transcript[species_name], verbose=verbose)
            feature_ids_one_overlap_native = overlap_lists_native["one_overlap"]
            native_1to1 = get_reciprocal_1to1(all_overlaps_dict, feature_ids_one_overlap_native, verbose = verbose)

            native_required_overlap_numbers = get_plot_numbers(overlap_lists_native, native_1to1, ratio=True, verbose = verbose)

            all_species_values_native[species_name] = native_required_overlap_numbers
            if verbose:
                print("\n\t --> transcripts (orthoDB)")

            overlap_lists_orthoDB = read_overlap_num_file(orthodb_query_transcript[species_name], verbose=verbose)
            feature_ids_one_overlap_orthoDB = overlap_lists_orthoDB["one_overlap"]
            orthoDB_1to1 = get_reciprocal_1to1(all_overlaps_dict, feature_ids_one_overlap_orthoDB, verbose = verbose)

            orthoDB_required_overlap_numbers = get_plot_numbers(overlap_lists_orthoDB, orthoDB_1to1, ratio=True, verbose = verbose)

            all_species_values_orthoDB[species_name] = orthoDB_required_overlap_numbers

        # print(all_species_values)
        ## TODO plot all_species_values
        # print(f"native: \n\t{all_species_values_native}")
        # print(f"orthoDB: \n\t{all_species_values_orthoDB}")
        
        tree_filepath = "/Users/miltr339/Box Sync/code/annotation_pipeline/annotation_scripts_ordered/14_species_orthofinder_tree.nw"
        species_order = gff.make_species_order_from_tree(tree_filepath)

        plot_all_species_values(all_values_native_dict=all_species_values_native, all_values_orthoDB_dict=all_species_values_orthoDB, species_names_list=species_order, filename = "annotaion_overlaps_transcript_level.png")


        ## --> exon features
    if True:
        all_species_values_native = {}
        all_species_values_orthoDB = {}
        
        verbose = False
        
        if verbose:
            print(f"get all values for all species:")
        for species_name in overlap_files_exon.keys():
        #for species_name in tqdm(overlap_files_transcript.keys()): 
            if verbose:
                print(f"\n\n================> {species_name} <================")
            
            all_overlaps_dict = read_overlaps(overlap_files_exon[species_name], verbose=verbose)
            if verbose:
                print("\n\t --> transcripts (native)")

            overlap_lists_native = read_overlap_num_file(native_query_exon[species_name], verbose=verbose)
            feature_ids_one_overlap_native = overlap_lists_native["one_overlap"]
            native_1to1 = get_reciprocal_1to1(all_overlaps_dict, feature_ids_one_overlap_native, verbose = verbose)

            native_required_overlap_numbers = get_plot_numbers(overlap_lists_native, native_1to1, ratio=True, verbose = verbose)

            all_species_values_native[species_name] = native_required_overlap_numbers
            if verbose:
                print("\n\t --> transcripts (orthoDB)")

            overlap_lists_orthoDB = read_overlap_num_file(orthodb_query_exon[species_name], verbose=verbose)
            feature_ids_one_overlap_orthoDB = overlap_lists_orthoDB["one_overlap"]
            orthoDB_1to1 = get_reciprocal_1to1(all_overlaps_dict, feature_ids_one_overlap_orthoDB, verbose = verbose)

            orthoDB_required_overlap_numbers = get_plot_numbers(overlap_lists_orthoDB, orthoDB_1to1, ratio=True, verbose = verbose)

            all_species_values_orthoDB[species_name] = orthoDB_required_overlap_numbers

        # print(all_species_values)
        ## TODO plot all_species_values
        # print(f"native: \n\t{all_species_values_native}")
        # print(f"orthoDB: \n\t{all_species_values_orthoDB}")
        
        tree_filepath = "/Users/miltr339/Box Sync/code/annotation_pipeline/annotation_scripts_ordered/14_species_orthofinder_tree.nw"
        species_order = gff.make_species_order_from_tree(tree_filepath)

        plot_all_species_values(all_values_native_dict=all_species_values_native, all_values_orthoDB_dict=all_species_values_orthoDB, species_names_list=species_order, filename = "annotaion_overlaps_exon_level.png")